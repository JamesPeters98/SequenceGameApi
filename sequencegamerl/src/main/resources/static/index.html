<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Sequence Game RL Trainer</title>
  <style>
    :root {
      --bg: #f6f7fb;
      --panel: #ffffff;
      --text: #1f2937;
      --muted: #6b7280;
      --primary: #0f766e;
      --primary-contrast: #ffffff;
      --border: #d1d5db;
      --danger: #b91c1c;
      --shadow: 0 10px 24px rgba(15, 23, 42, 0.08);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "Segoe UI", Tahoma, sans-serif;
      background: radial-gradient(circle at top right, #e6fffa, transparent 42%), var(--bg);
      color: var(--text);
    }

    .page {
      max-width: 1100px;
      margin: 0 auto;
      padding: 24px 16px 40px;
    }

    h1 {
      margin: 0 0 4px;
      font-size: 1.8rem;
    }

    .subtitle {
      margin: 0 0 24px;
      color: var(--muted);
    }

    .grid {
      display: grid;
      gap: 16px;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      margin-bottom: 16px;
    }

    .panel {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      box-shadow: var(--shadow);
      padding: 16px;
    }

    .panel h2 {
      margin: 0 0 12px;
      font-size: 1.1rem;
    }

    form {
      display: grid;
      gap: 10px;
    }

    label {
      display: grid;
      gap: 6px;
      font-size: 0.9rem;
      color: var(--muted);
    }

    input,
    select,
    button {
      font: inherit;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 9px 10px;
    }

    button {
      background: var(--primary);
      color: var(--primary-contrast);
      border-color: var(--primary);
      font-weight: 600;
      cursor: pointer;
    }

    button:disabled {
      opacity: 0.7;
      cursor: wait;
    }

    .status {
      margin-top: 8px;
      min-height: 1.2em;
      color: var(--muted);
      font-size: 0.9rem;
    }

    .status.error {
      color: var(--danger);
    }

    .metrics {
      display: grid;
      gap: 8px;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      margin-top: 10px;
    }

    .metric {
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px;
      background: #f9fafb;
    }

    .metric .name {
      display: block;
      font-size: 0.8rem;
      color: var(--muted);
      margin-bottom: 4px;
    }

    .metric .value {
      font-size: 1.05rem;
      font-weight: 600;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 12px;
      font-size: 0.92rem;
    }

    th,
    td {
      text-align: left;
      border-bottom: 1px solid var(--border);
      padding: 7px 6px;
    }

    .note {
      margin-top: 8px;
      font-size: 0.85rem;
      color: var(--muted);
    }

    .inline-link {
      color: var(--primary);
      text-decoration: none;
      font-weight: 600;
    }

    .inline-link:hover {
      text-decoration: underline;
    }
  </style>
</head>
<body>
  <main class="page">
    <h1>Sequence Game RL Trainer</h1>
    <p class="subtitle">Run DL4J training or validate Sequence API integration with random legal gameplay.</p>

    <section class="grid">
      <article class="panel">
        <h2>Training Run</h2>
        <form id="training-form">
          <label>
            Game
            <select id="gameId" name="gameId" required></select>
          </label>

          <label>
            Epochs
            <input id="epochs" name="epochs" type="number" value="12" min="1" max="250" required>
          </label>

          <label>
            Training Samples / Epoch
            <input id="trainingSamplesPerEpoch" name="trainingSamplesPerEpoch" type="number" value="2000" min="128" max="20000" required>
          </label>

          <label>
            Evaluation Samples
            <input id="evaluationSamples" name="evaluationSamples" type="number" value="400" min="128" max="10000" required>
          </label>

          <label>
            Batch Size
            <input id="batchSize" name="batchSize" type="number" value="64" min="8" max="1024" required>
          </label>

          <label>
            Seed
            <input id="seed" name="seed" type="number" value="42" required>
          </label>

          <button id="runButton" type="submit">Start Training</button>
        </form>
        <p class="status" id="status">Loading games...</p>
      </article>

      <article class="panel">
        <h2>Training Result</h2>
        <div class="metrics" id="summary"></div>
        <div id="historyWrap" style="display:none">
          <table>
            <thead>
              <tr>
                <th>Epoch</th>
                <th>Loss</th>
                <th>Accuracy</th>
              </tr>
            </thead>
            <tbody id="history"></tbody>
          </table>
        </div>
        <p class="note">DL4J UI (if enabled): <a class="inline-link" href="http://localhost:9000" target="_blank" rel="noopener noreferrer">http://localhost:9000</a></p>
      </article>

      <article class="panel">
        <h2>Sequence API Session</h2>
        <form id="sequence-init-form">
          <label>
            Player Count
            <input id="sequencePlayerCount" name="playerCount" type="number" value="2" min="2" max="12" required>
          </label>
          <button id="sequenceInitButton" type="submit">Init Game</button>
        </form>
        <p class="status" id="sequenceStatus">Ready.</p>
        <p class="note">Initialize first to get a game UUID, then start auto-play.</p>

        <form id="sequence-start-form" style="margin-top:14px">
          <label>
            Game UUID
            <input id="sequenceGameUuid" name="gameUuid" type="text" placeholder="Set by init or paste manually" required>
          </label>
          <label>
            Max Turns
            <input id="sequenceMaxTurns" name="maxTurns" type="number" value="500" min="1" max="10000" required>
          </label>
          <label>
            Move Delay (ms)
            <input id="sequenceMoveDelayMs" name="moveDelayMs" type="number" value="500" min="0" max="20000" required>
          </label>
          <label>
            Seed (optional)
            <input id="sequenceSeed" name="seed" type="number" placeholder="Current time seed">
          </label>
          <button id="sequenceStartButton" type="submit">Start Auto-Play</button>
        </form>
      </article>

      <article class="panel">
        <h2>Sequence Session Status</h2>
        <div class="metrics" id="sequenceSummary"></div>
        <p class="note">Action masking enforces normal cards, one-eyed jacks, and two-eyed jacks. Status auto-refreshes while running.</p>
      </article>

      <article class="panel">
        <h2>Sequence RL Training</h2>
        <form id="sequence-train-form">
          <label>
            Episodes
            <input id="sequenceTrainEpisodes" name="episodes" type="number" value="30" min="1" max="1000" required>
          </label>
          <label>
            Player Count
            <input id="sequenceTrainPlayerCount" name="playerCount" type="number" value="2" min="2" max="12" required>
          </label>
          <label>
            Max Turns / Episode
            <input id="sequenceTrainMaxTurns" name="maxTurnsPerEpisode" type="number" value="350" min="10" max="5000" required>
          </label>
          <label>
            Gamma
            <input id="sequenceTrainGamma" name="gamma" type="number" value="0.95" step="0.01" min="0.5" max="0.999" required>
          </label>
          <label>
            Epsilon Start
            <input id="sequenceTrainEpsStart" name="epsilonStart" type="number" value="0.25" step="0.01" min="0" max="1" required>
          </label>
          <label>
            Epsilon End
            <input id="sequenceTrainEpsEnd" name="epsilonEnd" type="number" value="0.05" step="0.01" min="0" max="1" required>
          </label>
          <label>
            Seed
            <input id="sequenceTrainSeed" name="seed" type="number" placeholder="Random each run">
          </label>
          <button id="sequenceTrainButton" type="submit">Run RL Training</button>
        </form>
        <p class="status" id="sequenceTrainStatus">Ready.</p>
      </article>

      <article class="panel">
        <h2>RL Training Result</h2>
        <div class="metrics" id="sequenceTrainSummary"></div>
        <div id="sequenceTrainChartWrap" style="display:none; margin-top:12px;">
          <svg id="sequenceTrainChart" viewBox="0 0 640 220" width="100%" height="220" aria-label="Episode reward chart"></svg>
        </div>
        <div id="sequenceTrainMovesChartWrap" style="display:none; margin-top:12px;">
          <svg id="sequenceTrainMovesChart" viewBox="0 0 640 220" width="100%" height="220" aria-label="Average learner moves chart"></svg>
        </div>
      </article>

      <article class="panel">
        <h2>RL Evaluation</h2>
        <form id="sequence-eval-form">
          <label>
            Episodes
            <input id="sequenceEvalEpisodes" name="episodes" type="number" value="50" min="1" max="2000" required>
          </label>
          <label>
            Player Count
            <input id="sequenceEvalPlayerCount" name="playerCount" type="number" value="2" min="2" max="12" required>
          </label>
          <label>
            Max Turns / Episode
            <input id="sequenceEvalMaxTurns" name="maxTurnsPerEpisode" type="number" value="350" min="10" max="5000" required>
          </label>
          <label>
            Seed
            <input id="sequenceEvalSeed" name="seed" type="number" value="4242" required>
          </label>
          <button id="sequenceEvalButton" type="submit">Run Evaluation</button>
        </form>
        <p class="status" id="sequenceEvalStatus">Ready.</p>
      </article>

      <article class="panel">
        <h2>Evaluation Result</h2>
        <div class="metrics" id="sequenceEvalSummary"></div>
      </article>
    </section>
  </main>

  <script>
    const trainingForm = document.getElementById('training-form');
    const statusEl = document.getElementById('status');
    const runButton = document.getElementById('runButton');
    const gameSelect = document.getElementById('gameId');
    const summary = document.getElementById('summary');
    const historyWrap = document.getElementById('historyWrap');
    const historyBody = document.getElementById('history');

    const sequenceInitForm = document.getElementById('sequence-init-form');
    const sequenceStartForm = document.getElementById('sequence-start-form');
    const sequenceStatusEl = document.getElementById('sequenceStatus');
    const sequenceInitButton = document.getElementById('sequenceInitButton');
    const sequenceStartButton = document.getElementById('sequenceStartButton');
    const sequenceGameUuidInput = document.getElementById('sequenceGameUuid');
    const sequenceSummary = document.getElementById('sequenceSummary');
    const sequenceTrainForm = document.getElementById('sequence-train-form');
    const sequenceTrainButton = document.getElementById('sequenceTrainButton');
    const sequenceTrainStatusEl = document.getElementById('sequenceTrainStatus');
    const sequenceTrainSummary = document.getElementById('sequenceTrainSummary');
    const sequenceTrainChartWrap = document.getElementById('sequenceTrainChartWrap');
    const sequenceTrainChart = document.getElementById('sequenceTrainChart');
    const sequenceTrainMovesChartWrap = document.getElementById('sequenceTrainMovesChartWrap');
    const sequenceTrainMovesChart = document.getElementById('sequenceTrainMovesChart');
    const sequenceEvalForm = document.getElementById('sequence-eval-form');
    const sequenceEvalButton = document.getElementById('sequenceEvalButton');
    const sequenceEvalStatusEl = document.getElementById('sequenceEvalStatus');
    const sequenceEvalSummary = document.getElementById('sequenceEvalSummary');
    let sequencePollHandle = null;

    function setStatus(message, isError = false) {
      statusEl.textContent = message;
      statusEl.classList.toggle('error', isError);
    }

    function setSequenceStatus(message, isError = false) {
      sequenceStatusEl.textContent = message;
      sequenceStatusEl.classList.toggle('error', isError);
    }

    function setSequenceTrainStatus(message, isError = false) {
      sequenceTrainStatusEl.textContent = message;
      sequenceTrainStatusEl.classList.toggle('error', isError);
    }

    function setSequenceEvalStatus(message, isError = false) {
      sequenceEvalStatusEl.textContent = message;
      sequenceEvalStatusEl.classList.toggle('error', isError);
    }

    function formatNumber(value, digits = 4) {
      if (typeof value !== 'number' || Number.isNaN(value)) {
        return '-';
      }
      return value.toFixed(digits);
    }

    function metric(label, value) {
      return `<div class="metric"><span class="name">${label}</span><span class="value">${value}</span></div>`;
    }

    async function loadGames() {
      const response = await fetch('/api/games');
      if (!response.ok) {
        throw new Error(`Failed to load games (${response.status})`);
      }

      const games = await response.json();
      if (!Array.isArray(games) || games.length === 0) {
        throw new Error('No games are registered');
      }

      gameSelect.innerHTML = games
        .map(game => `<option value="${game.id}">${game.displayName}</option>`)
        .join('');
    }

    function renderTrainingResult(result) {
      summary.innerHTML = [
        metric('Game', result.gameName || result.gameId),
        metric('Duration (ms)', String(result.durationMs)),
        metric('Final Loss', formatNumber(result.finalLoss, 6)),
        metric('Final Accuracy', formatNumber(result.finalAccuracy, 4)),
        metric('Epochs', String(result.epochs)),
        metric('Batch Size', String(result.batchSize))
      ].join('');

      const history = Array.isArray(result.history) ? result.history : [];
      historyBody.innerHTML = history
        .map(entry => `<tr><td>${entry.epoch}</td><td>${formatNumber(entry.loss, 6)}</td><td>${formatNumber(entry.accuracy, 4)}</td></tr>`)
        .join('');
      historyWrap.style.display = history.length > 0 ? 'block' : 'none';
    }

    function renderSequenceStatus(result) {
      sequenceSummary.innerHTML = [
        metric('Game UUID', result.gameUuid),
        metric('Status', result.status),
        metric('Running', result.running ? 'Yes' : 'No'),
        metric('Winner', result.winner || '-'),
        metric('Turns', String(result.turnsPlayed)),
        metric('Max Turns', String(result.maxTurns)),
        metric('Players', String(result.playerCount)),
        metric('Move Delay (ms)', String(result.moveDelayMs)),
        metric('Seed', String(result.seed)),
        metric('Current Turn', result.currentPlayerTurn || '-')
      ].join('');
    }

    function renderSequenceTrainResult(result) {
      sequenceTrainSummary.innerHTML = [
        metric('Episodes', String(result.episodes)),
        metric('Players', String(result.playerCount)),
        metric('Wins', String(result.wins)),
        metric('Losses', String(result.losses)),
        metric('Unfinished', String(result.unfinished)),
        metric('Learner Moves', String(result.totalLearnerMoves)),
        metric('Avg Reward', formatNumber(result.averageEpisodeReward, 4)),
        metric('Avg TD Error', formatNumber(result.averageTdError, 6)),
        metric('Duration (ms)', String(result.durationMs))
      ].join('');

      renderEpisodeRewardChart(result.history || []);
      renderAverageLearnerMovesChart(result.history || []);
    }

    function renderEpisodeRewardChart(history) {
      if (!Array.isArray(history) || history.length === 0) {
        sequenceTrainChartWrap.style.display = 'none';
        sequenceTrainChart.innerHTML = '';
        return;
      }

      const rewards = history.map(item => Number(item.totalReward));
      const minReward = Math.min(...rewards);
      const maxReward = Math.max(...rewards);
      const minY = minReward === maxReward ? minReward - 1 : minReward;
      const maxY = minReward === maxReward ? maxReward + 1 : maxReward;

      const width = 640;
      const height = 220;
      const padding = 28;
      const plotWidth = width - (padding * 2);
      const plotHeight = height - (padding * 2);

      const points = rewards.map((reward, index) => {
        const x = padding + (history.length === 1 ? 0 : (index / (history.length - 1)) * plotWidth);
        const y = padding + ((maxY - reward) / (maxY - minY)) * plotHeight;
        return `${x.toFixed(2)},${y.toFixed(2)}`;
      }).join(' ');

      const zeroLineVisible = minY <= 0 && maxY >= 0;
      let zeroLine = '';
      if (zeroLineVisible) {
        const zeroY = padding + ((maxY - 0) / (maxY - minY)) * plotHeight;
        zeroLine = `<line x1="${padding}" y1="${zeroY.toFixed(2)}" x2="${width - padding}" y2="${zeroY.toFixed(2)}" stroke="#d1d5db" stroke-dasharray="3 3" />`;
      }

      sequenceTrainChart.innerHTML = `
        <rect x="0" y="0" width="${width}" height="${height}" fill="#ffffff"></rect>
        <line x1="${padding}" y1="${padding}" x2="${padding}" y2="${height - padding}" stroke="#9ca3af" />
        <line x1="${padding}" y1="${height - padding}" x2="${width - padding}" y2="${height - padding}" stroke="#9ca3af" />
        ${zeroLine}
        <polyline fill="none" stroke="#0f766e" stroke-width="2.5" points="${points}" />
        <text x="${padding}" y="18" fill="#6b7280" font-size="12">Max: ${maxReward.toFixed(2)}</text>
        <text x="${padding}" y="${height - 8}" fill="#6b7280" font-size="12">Min: ${minReward.toFixed(2)}</text>
        <text x="${width - padding}" y="${height - 8}" fill="#6b7280" font-size="12" text-anchor="end">Episodes: ${history.length}</text>
      `;

      sequenceTrainChartWrap.style.display = 'block';
    }

    function renderAverageLearnerMovesChart(history) {
      if (!Array.isArray(history) || history.length === 0) {
        sequenceTrainMovesChartWrap.style.display = 'none';
        sequenceTrainMovesChart.innerHTML = '';
        return;
      }

      const runningAverages = [];
      let cumulative = 0;
      for (let i = 0; i < history.length; i++) {
        cumulative += Number(history[i].learnerMoves || 0);
        runningAverages.push(cumulative / (i + 1));
      }

      const minVal = Math.min(...runningAverages);
      const maxVal = Math.max(...runningAverages);
      const minY = minVal === maxVal ? minVal - 1 : minVal;
      const maxY = minVal === maxVal ? maxVal + 1 : maxVal;

      const width = 640;
      const height = 220;
      const padding = 28;
      const plotWidth = width - (padding * 2);
      const plotHeight = height - (padding * 2);

      const points = runningAverages.map((value, index) => {
        const x = padding + (history.length === 1 ? 0 : (index / (history.length - 1)) * plotWidth);
        const y = padding + ((maxY - value) / (maxY - minY)) * plotHeight;
        return `${x.toFixed(2)},${y.toFixed(2)}`;
      }).join(' ');

      const first = runningAverages[0];
      const last = runningAverages[runningAverages.length - 1];
      const trend = last < first ? 'down' : (last > first ? 'up' : 'flat');

      sequenceTrainMovesChart.innerHTML = `
        <rect x="0" y="0" width="${width}" height="${height}" fill="#ffffff"></rect>
        <line x1="${padding}" y1="${padding}" x2="${padding}" y2="${height - padding}" stroke="#9ca3af" />
        <line x1="${padding}" y1="${height - padding}" x2="${width - padding}" y2="${height - padding}" stroke="#9ca3af" />
        <polyline fill="none" stroke="#1d4ed8" stroke-width="2.5" points="${points}" />
        <text x="${padding}" y="18" fill="#6b7280" font-size="12">Max avg moves: ${maxVal.toFixed(2)}</text>
        <text x="${padding}" y="${height - 8}" fill="#6b7280" font-size="12">Min avg moves: ${minVal.toFixed(2)}</text>
        <text x="${width - padding}" y="${height - 8}" fill="#6b7280" font-size="12" text-anchor="end">Trend: ${trend}</text>
      `;

      sequenceTrainMovesChartWrap.style.display = 'block';
    }

    function renderSequenceEvalResult(result) {
      sequenceEvalSummary.innerHTML = [
        metric('Episodes', String(result.episodes)),
        metric('Players', String(result.playerCount)),
        metric('Win Rate', formatNumber(result.winRate * 100, 2) + '%'),
        metric('Wins', String(result.wins)),
        metric('Losses', String(result.losses)),
        metric('Unfinished', String(result.unfinished)),
        metric('Avg Reward', formatNumber(result.averageEpisodeReward, 4)),
        metric('Avg Moves', formatNumber(result.averageLearnerMoves, 2)),
        metric('Duration (ms)', String(result.durationMs))
      ].join('');
    }

    function stopSequencePolling() {
      if (sequencePollHandle !== null) {
        clearInterval(sequencePollHandle);
        sequencePollHandle = null;
      }
    }

    function startSequencePolling(gameUuid) {
      stopSequencePolling();
      sequencePollHandle = setInterval(async () => {
        try {
          const response = await fetch(`/api/sequence/session/${gameUuid}`);
          if (!response.ok) {
            return;
          }
          const status = await response.json();
          renderSequenceStatus(status);
          setSequenceStatus(status.message || 'Running...');
          if (!status.running) {
            stopSequencePolling();
          }
        } catch (ignored) {
        }
      }, 1000);
    }

    trainingForm.addEventListener('submit', async (event) => {
      event.preventDefault();
      runButton.disabled = true;
      summary.innerHTML = '';
      historyBody.innerHTML = '';
      historyWrap.style.display = 'none';
      setStatus('Training in progress. This can take some time...');

      const payload = {
        gameId: trainingForm.gameId.value,
        epochs: Number(trainingForm.epochs.value),
        trainingSamplesPerEpoch: Number(trainingForm.trainingSamplesPerEpoch.value),
        evaluationSamples: Number(trainingForm.evaluationSamples.value),
        batchSize: Number(trainingForm.batchSize.value),
        seed: Number(trainingForm.seed.value)
      };

      try {
        const response = await fetch('/api/training/run', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });

        if (!response.ok) {
          let message = `Training failed (${response.status})`;
          try {
            const errorBody = await response.json();
            if (errorBody && errorBody.message) {
              message = errorBody.message;
            }
          } catch (ignored) {
          }
          throw new Error(message);
        }

        const result = await response.json();
        renderTrainingResult(result);
        setStatus('Training completed successfully.');
      } catch (error) {
        setStatus(error.message || 'Unexpected training error', true);
      } finally {
        runButton.disabled = false;
      }
    });

    sequenceInitForm.addEventListener('submit', async (event) => {
      event.preventDefault();
      stopSequencePolling();
      sequenceInitButton.disabled = true;
      sequenceSummary.innerHTML = '';
      setSequenceStatus('Initializing game...');

      const payload = {
        playerCount: Number(sequenceInitForm.playerCount.value)
      };

      try {
        const response = await fetch('/api/sequence/session/init', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });

        if (!response.ok) {
          let message = `Init failed (${response.status})`;
          try {
            const errorBody = await response.json();
            if (errorBody && errorBody.message) {
              message = errorBody.message;
            }
          } catch (ignored) {
          }
          throw new Error(message);
        }

        const result = await response.json();
        sequenceGameUuidInput.value = result.gameUuid || '';
        sequenceSummary.innerHTML = [
          metric('Game UUID', result.gameUuid || '-'),
          metric('Status', result.status || '-'),
          metric('Players', String(result.playerCount || '-'))
        ].join('');
        setSequenceStatus(result.message || 'Game initialized.');
      } catch (error) {
        setSequenceStatus(error.message || 'Unexpected init error', true);
      } finally {
        sequenceInitButton.disabled = false;
      }
    });

    sequenceStartForm.addEventListener('submit', async (event) => {
      event.preventDefault();
      sequenceStartButton.disabled = true;
      setSequenceStatus('Starting auto-play...');

      const gameUuid = sequenceGameUuidInput.value.trim();
      if (!gameUuid) {
        setSequenceStatus('Game UUID is required.', true);
        sequenceStartButton.disabled = false;
        return;
      }

      const payload = {
        maxTurns: Number(sequenceStartForm.maxTurns.value),
        moveDelayMs: Number(sequenceStartForm.moveDelayMs.value)
      };

      const seedValue = sequenceStartForm.seed.value.trim();
      if (seedValue.length > 0) {
        payload.seed = Number(seedValue);
      }

      try {
        const response = await fetch(`/api/sequence/session/${gameUuid}/start`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });

        if (!response.ok) {
          let message = `Start failed (${response.status})`;
          try {
            const errorBody = await response.json();
            if (errorBody && errorBody.message) {
              message = errorBody.message;
            }
          } catch (ignored) {
          }
          throw new Error(message);
        }

        const result = await response.json();
        renderSequenceStatus(result);
        setSequenceStatus(result.message || 'Auto-play started.');
        startSequencePolling(gameUuid);
      } catch (error) {
        setSequenceStatus(error.message || 'Unexpected start error', true);
      } finally {
        sequenceStartButton.disabled = false;
      }
    });

    sequenceTrainForm.addEventListener('submit', async (event) => {
      event.preventDefault();
      sequenceTrainButton.disabled = true;
      sequenceTrainSummary.innerHTML = '';
      sequenceTrainChartWrap.style.display = 'none';
      sequenceTrainChart.innerHTML = '';
      sequenceTrainMovesChartWrap.style.display = 'none';
      sequenceTrainMovesChart.innerHTML = '';
      setSequenceTrainStatus('Training in progress. This can take a while...');

      const payload = {
        episodes: Number(sequenceTrainForm.episodes.value),
        playerCount: Number(sequenceTrainForm.playerCount.value),
        maxTurnsPerEpisode: Number(sequenceTrainForm.maxTurnsPerEpisode.value),
        gamma: Number(sequenceTrainForm.gamma.value),
        epsilonStart: Number(sequenceTrainForm.epsilonStart.value),
        epsilonEnd: Number(sequenceTrainForm.epsilonEnd.value)
      };

      const trainingSeedValue = sequenceTrainForm.seed.value.trim();
      if (trainingSeedValue.length > 0) {
        payload.seed = Number(trainingSeedValue);
      }

      try {
        const response = await fetch('/api/sequence/train', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });

        if (!response.ok) {
          let message = `Training failed (${response.status})`;
          try {
            const errorBody = await response.json();
            if (errorBody && errorBody.message) {
              message = errorBody.message;
            }
          } catch (ignored) {
          }
          throw new Error(message);
        }

        const result = await response.json();
        renderSequenceTrainResult(result);
        setSequenceTrainStatus(result.message || 'RL training complete.');
      } catch (error) {
        setSequenceTrainStatus(error.message || 'Unexpected RL training error', true);
      } finally {
        sequenceTrainButton.disabled = false;
      }
    });

    sequenceEvalForm.addEventListener('submit', async (event) => {
      event.preventDefault();
      sequenceEvalButton.disabled = true;
      setSequenceEvalStatus('Running evaluation...');
      sequenceEvalSummary.innerHTML = '';

      const payload = {
        episodes: Number(sequenceEvalForm.episodes.value),
        playerCount: Number(sequenceEvalForm.playerCount.value),
        maxTurnsPerEpisode: Number(sequenceEvalForm.maxTurnsPerEpisode.value),
        seed: Number(sequenceEvalForm.seed.value)
      };

      try {
        const response = await fetch('/api/sequence/evaluate', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });

        if (!response.ok) {
          let message = `Evaluation failed (${response.status})`;
          try {
            const errorBody = await response.json();
            if (errorBody && errorBody.message) {
              message = errorBody.message;
            }
          } catch (ignored) {
          }
          throw new Error(message);
        }

        const result = await response.json();
        renderSequenceEvalResult(result);
        setSequenceEvalStatus(result.message || 'Evaluation complete.');
      } catch (error) {
        setSequenceEvalStatus(error.message || 'Unexpected evaluation error', true);
      } finally {
        sequenceEvalButton.disabled = false;
      }
    });

    (async () => {
      try {
        await loadGames();
        setStatus('Ready. Configure settings and start training.');
      } catch (error) {
        setStatus(error.message || 'Unable to load games', true);
        runButton.disabled = true;
      }
    })();
  </script>
</body>
</html>
